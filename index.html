<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Danielle's Ta-Te-Ti</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ff69b4">
    <link rel="apple-touch-icon" href="icons/icon-192.png">

    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&display=swap" rel="stylesheet" />
    <style>
        /* ------------  PALETA  ------------ */
        :root {
            --pink-light: #ffc0cb;
            --pink:       #ff69b4;
            --pink-dark:  #ff1493;
            --pink-extra: #ffe4e1;
            --radius: 12px;
        }
        *{box-sizing:border-box;}
        body{
            display:flex;flex-direction:column;align-items:center;justify-content:center;
            min-height:100vh;margin:0;font-family:"Bubblegum Sans",cursive;
            background:var(--pink-light);color:var(--pink);overflow-x:hidden;
            transition:background .4s;
        }
        h1{margin:.1em 0 .4em;font-size:clamp(2.2rem,4vw+0.5rem,3.5rem);text-shadow:2px 2px rgba(0,0,0,.1);}

        /* ------------  TABLERO  ------------ */
        #game{
            display:grid;
            grid-template-columns:repeat(3,min(24vw,120px));
            grid-template-rows:repeat(3,min(24vw,120px));
            gap:min(3vw,10px);
            padding:10px;
            background:#fff;border:6px solid var(--pink);border-radius:var(--radius);
            box-shadow:0 6px 18px rgba(0,0,0,.25);user-select:none;
            transition:border-color .3s,box-shadow .3s;
        }
        .cell{display:flex;align-items:center;justify-content:center;width:100%;height:100%;font-size:clamp(2rem,6vw,4rem);background:var(--pink-extra);border:2px solid #ffb6c1;border-radius:var(--radius);cursor:pointer;transition:background .15s ease;position:relative;overflow:hidden;}
        .cell:hover:not(.disabled){background:var(--pink-light);}
        .cell.disabled{cursor:default;opacity:.7;}
        .cell.rainbow::after{content:"";position:absolute;inset:0;background:linear-gradient(45deg,red,orange,yellow,green,blue,indigo,violet,red);background-size:400% 400%;animation:rb 2s linear infinite;opacity:.7;z-index:0;}
        .cell span{position:relative;z-index:1;}
        @keyframes rb{0%{background-position:0 50%}100%{background-position:100% 50%}}
        @keyframes cellSelectAnim{0%{transform:scale(.9)}100%{transform:scale(1)}}

        /* ------------  STATUS  ------------ */
        #status{
            font-size:clamp(1.2rem,3vw,1.6rem);
            min-height:2.2rem;text-align:center;
            transition:transform .3s,color .3s;
            margin-bottom:clamp(10px,2vh,15px);
        }
        #status.highlight{transform:scale(1.2);color:var(--pink-dark);}

        /* ------------  SCORE  ------------ */
        #results{margin-top:clamp(10px,3vh,20px);padding:6px 14px;background:#fff;border:2px dashed var(--pink);border-radius:var(--radius);font-size:clamp(1rem,2.5vw,1.3rem);}
        #results span{min-width:2ch;display:inline-block;font-weight:bold;}

        /* ------------  TOP-BAR  ------------ */
        .top-bar{position:fixed;top:10px;left:10px;right:10px;display:flex;align-items:center;justify-content:space-between;pointer-events:none;z-index:200;}
        .top-bar button{pointer-events:auto;}
        .icon-btn{background:none;border:none;cursor:pointer;font-size:2rem;padding:4px;line-height:1;color:var(--pink-dark);transition:transform .15s;}
        .icon-btn:hover{transform:scale(1.1);}

        /* ------------  SIDE-MENU  ------------ */
        #menu-toggle{font-size:2.2rem;}
        .side-menu{position:fixed;top:0;left:0;height:100vh;width:clamp(250px,70vw,300px);background:var(--pink-light);box-shadow:3px 0 8px rgba(0,0,0,.15);transform:translateX(-100%);transition:transform .3s ease;padding:70px 14px 20px;display:flex;flex-direction:column;gap:18px;z-index:150;overflow-y:auto;}
        .side-menu.open{transform:translateX(0);}
        .side-menu .controls-group{display:flex;flex-direction:column;gap:14px;align-items:center;}
        .side-menu .controls-group>div{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;}
        .side-menu .controls-group>div>span{width:100%;text-align:center;margin-bottom:-5px;font-size:.9rem;color:var(--pink-dark);}
        button.std{padding:8px 20px;font-size:1rem;background:var(--pink);color:#fff;border:none;border-radius:var(--radius);cursor:pointer;transition:filter .15s,box-shadow .15s;}
        button.std:hover{filter:brightness(.9);}
        button.std.active{outline:3px solid var(--pink-dark);filter:brightness(.88);box-shadow:0 0 5px var(--pink-dark);}

        #restartBtn{display:none;}

        /* Confetti  */
        .confetti{position:fixed;border-radius:4px;pointer-events:none;z-index:1000;}
        @keyframes fall{to{transform:translateY(110vh) rotateZ(720deg);opacity:0;}}

        /* Draw Animation Styles */
        #status.highlight-draw-flash{animation:drawStatusFlash .3s 6 alternate;}
        @keyframes drawStatusFlash{from{color:var(--pink-dark);transform:scale(1.25);}to{color:var(--pink);transform:scale(1);}}
        #game.highlight-draw-border{animation:drawBoardFlash .3s 6 alternate;}
        @keyframes drawBoardFlash{0%{border-color:var(--pink-dark);box-shadow:0 0 15px var(--pink-dark);}50%{border-color:var(--pink-light);box-shadow:0 0 5px var(--pink-light);}100%{border-color:var(--pink-dark);box-shadow:0 0 15px var(--pink-dark);}}

        /* dark theme modifiers  */
        body.dark-theme{background:#2b2b2b;color:#ffc0cb;}
        body.dark-theme #game{background:#3d3d3d;border-color:var(--pink-dark);}
        body.dark-theme .cell{background:#4a4a4a;border-color:#5a5a5a;color:#fff;}
        body.dark-theme #results{background:#3d3d3d;border-color:var(--pink-dark);color:#fff;}
        body.dark-theme .side-menu{background:#3d3d3d;}
        body.dark-theme .side-menu .controls-group>div>span{color:var(--pink-light);}
        body.dark-theme .icon-btn{color:var(--pink-light);}

        @media(max-width:500px){
            #game{gap:min(2vw,8px);}
            h1{font-size:clamp(2rem,7vw,2.7rem);}
            #results{font-size:clamp(.9rem,3vw,1rem);}
            .side-menu{padding-top:60px;}
            .icon-btn{font-size:1.8rem;}
            #menu-toggle{font-size:2rem;}
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <button id="menu-toggle" class="icon-btn" aria-label="Men√∫">‚ò∞</button>
        <button id="restart-icon" class="icon-btn" aria-label="Reiniciar">üîÑ</button>
    </div>

    <h1>Ta-Te-Ti</h1>
    <div id="status" aria-live="polite">Turno del ü¶Ñ Unicornio</div>

    <div id="game" role="grid" aria-label="Tablero de juego">
        <div class="cell" role="button" aria-label="Celda 1" data-index="0"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 2" data-index="1"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 3" data-index="2"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 4" data-index="3"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 5" data-index="4"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 6" data-index="5"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 7" data-index="6"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 8" data-index="7"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 9" data-index="8"><span></span></div>
    </div>

    <div id="results">ü¶Ñ <span id="unicornWins">0</span> ‚Äì ‚ù§Ô∏è <span id="heartWins">0</span> ‚Äì ü§ù <span id="draws">0</span></div>

    <nav id="side-menu" class="side-menu" aria-label="Opciones">
        <div class="controls-group">
            <div><span>Modo de Juego:</span></div>
                <div class="mode" aria-label="Seleccionar modo">
                    <button id="pvpLocalBtn" class="std mode-btn active">Mismo Dispositivo</button>
                    <button id="hostGameBtn" class="std mode-btn">Hostear Juego Remoto</button>
                    <button id="joinGameBtn" class="std mode-btn">Unirse a Juego Remoto</button>
                    <button id="cpuBtn" class="std mode-btn">Jugador vs CPU</button>
                </div>
            <div><span>Dificultad CPU:</span></div>
            <div class="difficulty" aria-label="Seleccionar dificultad" style="display:none;">
                <button id="easyBtn" class="std difficulty-btn">F√°cil</button>
                <button id="mediumBtn" class="std difficulty-btn active">Normal</button>
                <button id="hardBtn" class="std difficulty-btn">Dif√≠cil</button>
            </div>
            <div><span>Qui√©n Empieza:</span></div>
            <div class="game-start-options" aria-label="Seleccionar qui√©n empieza">
                <button id="player1StartsBtn" class="std start-option-btn">Jugador 1</button>
                <button id="randomStartsBtn" class="std start-option-btn">Aleatorio</button>
                <button id="loserStartsBtn" class="std start-option-btn">Perdedor</button>
            </div>
            <button id="changeSymbolsBtn" class="std" style="margin-top:10px;">Cambiar s√≠mbolos</button>
        </div>
        <div style="margin-top:auto; display:flex; justify-content:space-around; padding-top:20px;">
            <button id="soundToggle" class="icon-btn" aria-label="Sonido">üîä</button>
            <button id="themeToggle" class="icon-btn" aria-label="Tema">üåô</button>
        </div>
    </nav>

    <button id="restartBtn" aria-hidden="true" style="display:none;">Restart</button>

  <div id="statusOverlay" style="
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #fff4f6;
    color: #ff1493;
    border: 2px solid #ff69b4;
    border-radius: 10px;
    padding: 8px 16px;
    font-size: 1.2rem;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    z-index: 1001;
    display: none;
    font-family: 'Bubblegum Sans', cursive;
  ">Esperando el movimiento del otro jugador...</div>

<script src="sound-multiplayer.js"></script>
<script>
/****************************************************
 * GAME LOGIC *
 ***************************************************/
document.addEventListener('DOMContentLoaded', () => {
    /* ----------  ELEMENTOS DEL DOM  ---------- */
    const cells             = document.querySelectorAll('.cell');
    const statusDiv         = document.getElementById('status');
    const restartBtn        = document.getElementById('restartBtn');
    const pvpLocalBtn       = document.getElementById('pvpLocalBtn');
    const hostGameBtn       = document.getElementById('hostGameBtn');
    const joinGameBtn       = document.getElementById('joinGameBtn');
    const cpuBtn            = document.getElementById('cpuBtn');
    const difficultyDiv     = document.querySelector('.difficulty');
    const easyBtn           = document.getElementById('easyBtn');
    const mediumBtn         = document.getElementById('mediumBtn');
    const hardBtn           = document.getElementById('hardBtn');
    const unicornSpan       = document.getElementById('unicornWins');
    const heartSpan         = document.getElementById('heartWins');
    const drawsSpan         = document.getElementById('draws');
    const themeToggle       = document.getElementById('themeToggle');
    const soundToggle       = document.getElementById('soundToggle');
    const changeSymbolsBtn  = document.getElementById('changeSymbolsBtn');
    const player1StartsBtn  = document.getElementById('player1StartsBtn');
    const randomStartsBtn   = document.getElementById('randomStartsBtn');
    const loserStartsBtn    = document.getElementById('loserStartsBtn');
    const gameBoardEl       = document.getElementById('game');

    const menuToggle        = document.getElementById('menu-toggle');
    const sideMenu          = document.getElementById('side-menu');
    const restartIcon       = document.getElementById('restart-icon');

    menuToggle.addEventListener('click', () => sideMenu.classList.toggle('open'));
    document.addEventListener('click', e => {
        if (!sideMenu.contains(e.target) && !menuToggle.contains(e.target) && sideMenu.classList.contains('open')) {
            sideMenu.classList.remove('open');
        }
    });
    
    /* ----------  ESTADO  ---------- */
    let board, currentPlayer, gameActive, vsCPU = false, difficulty = 'medium';
    let pvpRemoteActive = false; 
    let isMyTurnInRemote = true; 
    let iAmPlayer1InRemote = true; 
    let gamePaired = false; 

    let soundEnabled = !(localStorage.getItem('soundDisabled') === 'true');
    const symbolSet = [
        {player1:'ü¶Ñ',player2:'‚ù§Ô∏è'},{player1:'üê±',player2:'üê∂'},
        {player1:'üåû',player2:'üåô'},{player1:'‚ùå',player2:'‚≠ï'}
    ];
    let currentSymbolIndex = +(localStorage.getItem('currentSymbolIndex') || 0);
    let currentSymbols = symbolSet[currentSymbolIndex];

    let unicornWins = +localStorage.getItem('unicornWins') || 0;
    let heartWins   = +localStorage.getItem('heartWins') || 0;
    let draws       = +localStorage.getItem('draws') || 0;

    let whoGoesFirstSetting = localStorage.getItem('whoGoesFirstSetting') || 'player1';
    let lastWinner = null;
    let previousGameExists = (unicornWins + heartWins + draws) > 0;

    const AUTO_RESTART_DELAY_WIN = 5000;
    const AUTO_RESTART_DELAY_DRAW = 3000;

    /* ----------  AUDIO CONTEXT  ---------- */
    let audioCtx;
    function getAudioContext(){
        if(!audioCtx && soundEnabled){
            try{audioCtx = new (window.AudioContext||window.webkitAudioContext)();}
            catch(e){console.error("AudioContext error",e);soundEnabled=false;soundToggle.textContent='üîá';localStorage.setItem('soundDisabled',true);return null;}
        }
        if(audioCtx && audioCtx.state==='suspended'){
            audioCtx.resume().catch(err=>console.error("Error resuming AudioContext:", err));
        }
        return audioCtx;
    }
    function initAudioOnInteraction(){ if(soundEnabled && !audioCtx){ getAudioContext(); } }

    /* ----------  CONFETTI & DRAW ANIMATION  ---------- */
    function launchConfetti(){
        if(!soundEnabled) return;
        const confettiColors=['#ff3860','#ffdd57','#17d1a2','#3e8ed0','#b86bff','var(--pink)','var(--pink-dark)'];
        for(let i=0;i<100;i++){
            const c=document.createElement('div');
            c.classList.add('confetti');
            c.style.background=confettiColors[Math.floor(Math.random()*confettiColors.length)];
            c.style.left=`${Math.random()*100}vw`;
            c.style.top=`${Math.random()*-80-20}px`; // Start above screen
            const animDuration=Math.random()*2+3;
            const animDelay=Math.random()*0.5;
            c.style.width=`${Math.random()*6+6}px`;
            c.style.height=`${Math.random()*10+8}px`;
            c.style.opacity=`${Math.random()*0.4+0.6}`;
            c.style.transform=`rotate(${Math.random()*360}deg) scale(${Math.random()*0.5+0.5})`;
            c.style.animation=`fall ${animDuration}s ease-out ${animDelay}s forwards`;
            document.body.appendChild(c);
            setTimeout(()=>c.remove(),(animDuration+animDelay)*1000+200);
        }
    }
    function removeConfetti(){ document.querySelectorAll('.confetti').forEach(c=>c.remove()); }
    function playDrawAnimation(){
        const dur=1800; // ms
        statusDiv.classList.add('highlight-draw-flash');
        gameBoardEl.classList.add('highlight-draw-border');
        setTimeout(()=>{
            statusDiv.classList.remove('highlight-draw-flash');
            gameBoardEl.classList.remove('highlight-draw-border');
            gameBoardEl.style.borderColor=''; gameBoardEl.style.boxShadow=''; 
        },dur);
        return dur; 
    }

    /* ----------  L√ìGICA PRINCIPAL  ---------- */
    function setBoardClickable(clickable){
        cells.forEach(cellNode =>{ // Use a different variable name like cellNode to avoid conflict if 'cells' is used broadly
            if(clickable){ 
                board[cellNode.dataset.index] === null ? cellNode.classList.remove('disabled') : cellNode.classList.add('disabled');
            } else {
                cellNode.classList.add('disabled');
            }
        });
    }

    function getPlayerName(sym){
        if(sym===currentSymbols.player1)return `${sym} ${sym==='ü¶Ñ'?'Unicornio':sym==='üê±'?'Gatito':sym==='üåû'?'Sol':'Equis'}`;
        if(sym===currentSymbols.player2)return `${sym} ${sym==='‚ù§Ô∏è'?'Coraz√≥n':sym==='üê∂'?'Perrito':sym==='üåô'?'Luna':'C√≠rculo'}`;
        return sym; // Fallback
    }
    
    function updateAllUIToggleButtons(){
        pvpLocalBtn.classList.toggle('active', !vsCPU && !pvpRemoteActive);
        hostGameBtn.classList.toggle('active', pvpRemoteActive && iAmPlayer1InRemote && !gamePaired);
        joinGameBtn.classList.toggle('active', pvpRemoteActive && !iAmPlayer1InRemote && !gamePaired);
        cpuBtn.classList.toggle('active', vsCPU);

        document.getElementById('game').style.display = (pvpRemoteActive && !gamePaired) ? 'none' : 'grid';
        document.getElementById('results').style.display = (pvpRemoteActive && !gamePaired) ? 'none' : 'block';

        difficultyDiv.style.display = vsCPU ? 'flex' : 'none';
        easyBtn.classList.toggle('active',difficulty==='easy');
        mediumBtn.classList.toggle('active',difficulty==='medium');
        hardBtn.classList.toggle('active',difficulty==='hard');

        document.querySelector('.game-start-options').style.display = pvpRemoteActive ? 'none' : 'flex';
        player1StartsBtn.classList.toggle('active',whoGoesFirstSetting==='player1');
        randomStartsBtn.classList.toggle('active',whoGoesFirstSetting==='random');
        loserStartsBtn.classList.toggle('active',whoGoesFirstSetting==='loser');

        themeToggle.textContent=document.body.classList.contains('dark-theme')?'‚òÄÔ∏è':'üåô';
        soundToggle.textContent=soundEnabled?'üîä':'üîá';
    }

    function init(){
        removeConfetti();
        hideStatusOverlay();
        if (typeof stopListening === "function") stopListening(); // Ensure it's defined and called

        board=Array(9).fill(null);
        // vsCPU and pvpRemoteActive are set by button handlers before calling init in those cases

        difficulty = easyBtn.classList.contains('active')?'easy':hardBtn.classList.contains('active')?'hard':'medium';
        
        gameActive = false; // Default to not active until mode is confirmed

        if (pvpRemoteActive && gamePaired) {
            currentPlayer = iAmPlayer1InRemote ? currentSymbols.player1 : currentSymbols.player2;
            isMyTurnInRemote = iAmPlayer1InRemote; 
            statusDiv.textContent = isMyTurnInRemote ? `Tu Turno ${getPlayerName(currentPlayer)}` : `Esperando a ${getPlayerName(currentPlayer)}...`;
            setBoardClickable(isMyTurnInRemote);
            gameActive = true;
            if (!isMyTurnInRemote) {
                listenForRemoteMove();
            }
        } else if (pvpRemoteActive && !gamePaired) {
            statusDiv.textContent = iAmPlayer1InRemote ? "Esperando que alguien se una..." : "Buscando juego hosteado...";
            setBoardClickable(false);
            // gameActive remains false
        } else if (vsCPU) {
            gameActive = true;
            switch(whoGoesFirstSetting){
                case 'random': currentPlayer = Math.random()<.5?currentSymbols.player1:currentSymbols.player2; break;
                case 'loser':
                    currentPlayer = (!previousGameExists||lastWinner===null)?currentSymbols.player1:(lastWinner===currentSymbols.player1?currentSymbols.player2:currentSymbols.player1);
                    break;
                default: currentPlayer = currentSymbols.player1; // Player 1 (e.g., Unicorn) starts
            }
            statusDiv.textContent = `Turno del ${getPlayerName(currentPlayer)}`;
            if(currentPlayer===currentSymbols.player2){ // If CPU (Player 2) starts
                setBoardClickable(false);
                setTimeout(()=>{ if(gameActive) cpuMove(); if(gameActive) setBoardClickable(true);},700+Math.random()*300);
            } else {
                setBoardClickable(true);
            }
        } else { // Local PvP
            gameActive = true;
             switch(whoGoesFirstSetting){
                case 'random': currentPlayer = Math.random()<.5?currentSymbols.player1:currentSymbols.player2; break;
                case 'loser':
                    currentPlayer = (!previousGameExists||lastWinner===null)?currentSymbols.player1:(lastWinner===currentSymbols.player1?currentSymbols.player2:currentSymbols.player1);
                    break;
                default: currentPlayer = currentSymbols.player1;
            }
            statusDiv.textContent = `Turno del ${getPlayerName(currentPlayer)}`;
            setBoardClickable(true);
        }

        cells.forEach(c=>{c.querySelector('span').textContent='';c.classList.remove('rainbow','disabled');});
        statusDiv.classList.remove('highlight','highlight-draw-flash');
        gameBoardEl.classList.remove('highlight-draw-border');
        gameBoardEl.style.borderColor='';gameBoardEl.style.boxShadow='';
        
        updateAllUIToggleButtons();
        if(gameActive) playSound('reset');
        
        sideMenu.classList.remove('open');
    }

    function stopAnyGameInProgress() {
        gameActive = false;
        if (typeof stopListening === "function") stopListening();
        board = Array(9).fill(null); // Reset board
        cells.forEach(c => { c.querySelector('span').textContent = ''; c.classList.remove('rainbow', 'disabled'); });
        removeConfetti();
        hideStatusOverlay();
    }

    function handleHostGame() {
        stopAnyGameInProgress();
        pvpRemoteActive = true;
        vsCPU = false;
        iAmPlayer1InRemote = true;
        gamePaired = false;
        updateAllUIToggleButtons(); // Update UI to show host state
        statusDiv.textContent = "Hosteando... Enviando se√±al de pairing.";
        showStatusOverlay("Enviando se√±al para que otro jugador se una... üîä");
        
        if (typeof sendPairingRequest !== "function" || typeof startListeningForSounds !== "function") {
            console.error("Sound functions (sendPairingRequest or startListeningForSounds) not defined!");
            statusDiv.textContent = "Error: Funciones de sonido no encontradas.";
            return;
        }
        sendPairingRequest(); 
        startListeningForSounds('pair_accept', (signal) => {
            if (signal === 'pair_accept_detected') {
                gamePaired = true;
                hideStatusOverlay();
                playSound('win'); 
                statusDiv.textContent = "¬°Conectado! Eres Jugador 1 (ü¶Ñ). Iniciando...";
                init(); 
            } else {
                // statusDiv.textContent = "Error de pairing o se√±al inesperada. Reintentando...";
                // To avoid infinite loop on wrong signal, might add a timeout or retry limit here
                // For now, it will just keep listening if signal wasn't 'pair_accept_detected'
            }
        });
    }

    function handleJoinGame() {
        stopAnyGameInProgress();
        pvpRemoteActive = true;
        vsCPU = false;
        iAmPlayer1InRemote = false;
        gamePaired = false;
        updateAllUIToggleButtons(); 
        statusDiv.textContent = "Buscando juego... Escuchando se√±al de pairing.";
        showStatusOverlay("Escuchando para unirse a un juego... üîä");

        if (typeof startListeningForSounds !== "function" || typeof sendPairingAccept !== "function") {
            console.error("Sound functions (startListeningForSounds or sendPairingAccept) not defined!");
            statusDiv.textContent = "Error: Funciones de sonido no encontradas.";
            return;
        }
        startListeningForSounds('pair_request', (signal) => {
            if (signal === 'pair_request_detected') {
                hideStatusOverlay();
                statusDiv.textContent = "Juego encontrado! Enviando aceptaci√≥n...";
                playSound('move'); 
                sendPairingAccept(); 
                gamePaired = true;
                statusDiv.textContent = "¬°Conectado! Eres Jugador 2 (‚ù§Ô∏è). Iniciando...";
                init(); 
            } else {
                // statusDiv.textContent = "No se encontr√≥ juego. Reintentando...";
            }
        });
    }

    function makeMove(index, playerSymbol){
        if (board[index] !== null) return false; 
        board[index]=playerSymbol;
        cells[index].querySelector('span').textContent=playerSymbol;
        cells[index].classList.add('disabled');
        cells[index].style.animation='cellSelectAnim .3s ease';
        setTimeout(()=>cells[index].style.animation='',300);
        playSound('move');
        return true;
    }

    function listenForRemoteMove() {
        if (!pvpRemoteActive || isMyTurnInRemote || !gameActive || !gamePaired) {
            console.log("Not listening for remote move:", {pvpRemoteActive, isMyTurnInRemote, gameActive, gamePaired});
            return;
        }
        showStatusOverlay(`Esperando el movimiento de ${getPlayerName(currentPlayer)}... üîä`);
        if (typeof startListeningForSounds !== "function") {
            console.error("startListeningForSounds is not defined!");
            hideStatusOverlay();
            statusDiv.textContent = "Error cr√≠tico: Escucha de sonidos no disponible.";
            return;
        }
        startListeningForSounds('move', handleRemoteMoveDetected);
    }

    function handleRemoteMoveDetected(indexOrSignal) {
        hideStatusOverlay(); // Hide it once any sound is processed or we decide to re-listen

        if (typeof indexOrSignal !== 'number' || indexOrSignal < 0 || indexOrSignal > 8) {
            console.warn("Invalid move detected or wrong signal type for move:", indexOrSignal);
            // If still opponent's turn and expecting a move, re-listen.
            if (gameActive && pvpRemoteActive && !isMyTurnInRemote && gamePaired) {
                 console.log("Re-listening due to invalid signal.");
                 listenForRemoteMove(); 
            }
            return;
        }
        
        const index = indexOrSignal;

        if (!gameActive || board[index] !== null || !pvpRemoteActive || isMyTurnInRemote || !gamePaired) {
            console.warn("Remote move ignored due to invalid game state:", {index, gameActive, boardVal: board[index], pvpRemoteActive, isMyTurnInRemote, gamePaired});
            if (gameActive && pvpRemoteActive && !isMyTurnInRemote && gamePaired) {
                console.log("Re-listening due to invalid game state for received move.");
                listenForRemoteMove();
            }
            return;
        }

        // At this point, currentPlayer is the opponent who just made the move
        if (!makeMove(index, currentPlayer)) {
            console.error("Failed to make remote move on board, cell might be taken despite checks.");
             if (gameActive && pvpRemoteActive && !isMyTurnInRemote && gamePaired) listenForRemoteMove();
            return;
        }

        const win = checkWin(currentPlayer); // Check if the opponent (currentPlayer) won
        if (win) {
            endGame(currentPlayer, win);
            return;
        }
        if (checkDraw()) {
            endDraw();
            return;
        }

        switchPlayer(); // Switches currentPlayer to this device's player
        isMyTurnInRemote = true; // Now it's this device's turn
        statusDiv.textContent = `Tu Turno ${getPlayerName(currentPlayer)}`;
        setBoardClickable(true);
    }

    function handleCellClick(e){
        const idx = +e.currentTarget.dataset.index;
        
        if (!gameActive || board[idx] !== null ) return;
        if (pvpRemoteActive && (!isMyTurnInRemote || !gamePaired)) return; // If remote, must be my turn and paired

        if (!makeMove(idx, currentPlayer)) return; // currentPlayer is this device's player

        if (pvpRemoteActive && gamePaired) {
            if (typeof sendMoveViaSound !== "function") {
                 console.error("sendMoveViaSound is not defined!");
                 statusDiv.textContent = "Error: Funci√≥n para enviar sonido no disponible.";
                 // Potentially revert move or handle error
                 return;
            }
            sendMoveViaSound(idx); 
        }

        const win = checkWin(currentPlayer);
        if(win){ endGame(currentPlayer,win); return; }
        if(checkDraw()){ endDraw(); return; }

        switchPlayer(); // Switches to opponent for next turn display / CPU move

        if (pvpRemoteActive && gamePaired) {
            isMyTurnInRemote = false; 
            statusDiv.textContent = `Esperando a ${getPlayerName(currentPlayer)}...`; // currentPlayer is now opponent
            setBoardClickable(false);
            listenForRemoteMove();
        } else if(vsCPU && currentPlayer===currentSymbols.player2){ // currentPlayer is CPU
            setBoardClickable(false);
            setTimeout(()=>{ if(gameActive) cpuMove(); if(gameActive) setBoardClickable(true);},700+Math.random()*300);
        }
    }
    
    function cpuMove(){
        if(!gameActive) return;
        let idx;
        switch(difficulty){
            case 'easy': idx=randomMove(); break;
            case 'medium': idx=Math.random()<.75?bestMove():randomMove(); break;
            default: idx=bestMove(); // hard
        }
        if(idx===null || board[idx]!==null) idx=randomMove(); // Fallback if bestMove fails or returns taken
        if(idx===null){ if(checkDraw()) endDraw(); return; } // No moves left

        makeMove(idx,currentSymbols.player2); // CPU is always player2
        const win=checkWin(currentSymbols.player2);
        if(win){ endGame(currentSymbols.player2,win); return; }
        if(checkDraw()){ endDraw(); return; }
        switchPlayer(); // Switch back to human player
        // setBoardClickable(true) is handled by the calling context of cpuMove in init or handleCellClick
    }

    function randomMove(){
        const a=board.map((v,i)=>v===null?i:null).filter(v=>v!==null);
        return a.length? a[Math.floor(Math.random()*a.length)] : null;
    }

    function bestMove(){
        // Try to win
        for(let i=0;i<9;i++)if(!board[i]){board[i]=currentSymbols.player2;if(checkWin(currentSymbols.player2)){board[i]=null;return i;}board[i]=null;}
        // Try to block
        for(let i=0;i<9;i++)if(!board[i]){board[i]=currentSymbols.player1;if(checkWin(currentSymbols.player1)){board[i]=null;return i;}board[i]=null;}
        // Center
        if(board[4]===null) return 4;
        // Corners
        const corners=[0,2,6,8].filter(i=>board[i]===null);
        if(corners.length) return corners[Math.floor(Math.random()*corners.length)];
        // Random (should be covered by corners or earlier returns if game not full)
        return randomMove();
    }

    function checkWin(playerSymbol, currentBoard = board){
        const c=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        return c.find(combo=>combo.every(i=>currentBoard[i]===playerSymbol))||null;
    }

    function checkDraw(currentBoard = board){ 
        return currentBoard.every(cell=>cell!==null) && !checkWin(currentSymbols.player1, currentBoard) && !checkWin(currentSymbols.player2, currentBoard);
    }

    function endGame(playerSymbol, winningCells){
        if(!gameActive) return; // Prevent multiple calls
        gameActive=false; 
        setBoardClickable(false);
        hideStatusOverlay();
        if(typeof stopListening === "function") stopListening();

        if(winningCells) winningCells.forEach(i=>cells[i].classList.add('rainbow'));
        statusDiv.textContent=`¬°${getPlayerName(playerSymbol)} gan√≥!`; statusDiv.classList.add('highlight');
        
        if(playerSymbol===currentSymbols.player1){unicornWins++;localStorage.setItem('unicornWins',unicornWins);lastWinner=currentSymbols.player1;}
        else{heartWins++;localStorage.setItem('heartWins',heartWins);lastWinner=currentSymbols.player2;}
        previousGameExists=true; 
        updateScoreboard(); 
        playSound('win'); 
        launchConfetti();

        const autoRestartDelay = (pvpRemoteActive && gamePaired) ? AUTO_RESTART_DELAY_WIN + 2000 : AUTO_RESTART_DELAY_WIN;
        setTimeout(()=>{removeConfetti(); init();}, autoRestartDelay);
    }

    function endDraw(){
        if(!gameActive) return;
        gameActive=false; 
        setBoardClickable(false);
        hideStatusOverlay();
        if(typeof stopListening === "function") stopListening();

        statusDiv.textContent='¬°Empate!'; statusDiv.classList.add('highlight');
        draws++;localStorage.setItem('draws',draws);lastWinner=null;previousGameExists=true;
        updateScoreboard();
        playSound('draw');
        const animationDuration = playDrawAnimation();

        const autoRestartDelay = (pvpRemoteActive && gamePaired) ? Math.max(animationDuration + 200, AUTO_RESTART_DELAY_DRAW) + 2000 : Math.max(animationDuration + 200, AUTO_RESTART_DELAY_DRAW);
        setTimeout(()=>init(), autoRestartDelay);
    }

    function switchPlayer(){
        currentPlayer = (currentPlayer===currentSymbols.player1)?currentSymbols.player2:currentSymbols.player1;
        // Status updates are handled by calling functions (handleCellClick, handleRemoteMoveDetected, init)
        // to provide more context-specific messages, especially for remote play.
    }

    function updateScoreboard(){
        unicornSpan.textContent=unicornWins;heartSpan.textContent=heartWins;drawsSpan.textContent=draws;
    }

    function playSound(type){
        if(!soundEnabled||!getAudioContext()|| (audioCtx && audioCtx.state!=='running') ) return;
        try{
            const o=audioCtx.createOscillator();const g=audioCtx.createGain();o.connect(g);g.connect(audioCtx.destination);
            let f1=440,t=.2,gV=.08,wT='sine'; // Default values
            switch(type){
                case'move':f1=300+Math.random()*200;t=.15;gV=.06;wT='triangle';break;
                case'win':f1=600;const f2=900,f3=1200;t=.7;gV=.1;wT='sawtooth';o.frequency.setValueAtTime(f1,audioCtx.currentTime);o.frequency.linearRampToValueAtTime(f2,audioCtx.currentTime+t*.33);o.frequency.linearRampToValueAtTime(f3,audioCtx.currentTime+t*.66);break;
                case'draw':f1=330;const fD2=220;t=.4;gV=.07;wT='square';o.frequency.setValueAtTime(f1,audioCtx.currentTime);o.frequency.linearRampToValueAtTime(fD2,audioCtx.currentTime+t*.5);break;
                case'reset':f1=500;const fR2=300;t=.25;gV=.05;wT='sine';o.frequency.setValueAtTime(f1,audioCtx.currentTime);o.frequency.linearRampToValueAtTime(fR2,audioCtx.currentTime+t*.5);break;
                default:return; // Unknown sound type
            }
            o.type=wT;if(!['win','draw','reset'].includes(type)) o.frequency.setValueAtTime(f1,audioCtx.currentTime); // Set frequency if not complex
            g.gain.setValueAtTime(gV,audioCtx.currentTime);
            o.start();g.gain.exponentialRampToValueAtTime(.00001,audioCtx.currentTime+t);o.stop(audioCtx.currentTime+t+.05);
        }catch(err){console.error("Error playing sound:",err);}
    }

    function toggleTheme(){
        document.body.classList.toggle('dark-theme');
        localStorage.setItem('darkTheme',document.body.classList.contains('dark-theme'));
        updateAllUIToggleButtons(); playSound('move');
    }

    function toggleSound(){
        soundEnabled=!soundEnabled;localStorage.setItem('soundDisabled',!soundEnabled);
        if(soundEnabled) initAudioOnInteraction(); else {
            if(audioCtx&&audioCtx.state==='running') audioCtx.suspend().catch(e => console.error("Error suspending audio context:", e));
            if(typeof stopListening === "function") stopListening(); 
            hideStatusOverlay();
        }
        updateAllUIToggleButtons(); if(soundEnabled) playSound('move');
    }

    function changeSymbols(){
        currentSymbolIndex=(currentSymbolIndex+1)%symbolSet.length;localStorage.setItem('currentSymbolIndex',currentSymbolIndex);
        currentSymbols=symbolSet[currentSymbolIndex];
        
        // If game was in progress, current player symbol might need update if it was one of the old ones
        const oldPlayer1Symbol = symbolSet[(currentSymbolIndex - 1 + symbolSet.length) % symbolSet.length].player1;
        const oldPlayer2Symbol = symbolSet[(currentSymbolIndex - 1 + symbolSet.length) % symbolSet.length].player2;
        if (currentPlayer === oldPlayer1Symbol) currentPlayer = currentSymbols.player1;
        else if (currentPlayer === oldPlayer2Symbol) currentPlayer = currentSymbols.player2;

        const rDiv=document.getElementById('results');
        rDiv.childNodes[0].nodeValue=currentSymbols.player1+' '; // Update text node for P1 symbol
        rDiv.childNodes[2].nodeValue=' ‚Äì '+currentSymbols.player2+' '; // Update text node for P2 symbol
        
        playSound('move'); 
        init(); // Reinitialize to update board and status with new symbols
    }

    /* ----------  EVENT LISTENERS  ---------- */
    cells.forEach(c=>{c.addEventListener('click',handleCellClick);c.setAttribute('tabindex','0');c.addEventListener('keydown',e=>{if(['Enter',' '].includes(e.key)){e.preventDefault();c.click();}});});
    
    restartBtn.addEventListener('click',init); // Hidden button, mostly triggered by icon

    restartIcon.addEventListener('click', () => {
        stopAnyGameInProgress(); // Stops listeners, clears board etc.
        if (pvpRemoteActive) { // If it was a remote game
            pvpRemoteActive = false; // End remote session
            gamePaired = false;      // Reset paired status
             // UI will update via init() to show Host/Join options again.
        }
        init(); // Re-initialize the game (will go to local PvP by default if no other mode is active)
        if (sideMenu.classList.contains('open')) sideMenu.classList.remove('open');
    });

    pvpLocalBtn.addEventListener('click',()=>{
        stopAnyGameInProgress();
        vsCPU=false;
        pvpRemoteActive = false;
        gamePaired = false;
        init(); // This will set pvpLocalBtn active via updateAllUIToggleButtons
    });

    hostGameBtn.addEventListener('click', handleHostGame);
    joinGameBtn.addEventListener('click', handleJoinGame);
    
    cpuBtn.addEventListener('click',()=>{
        stopAnyGameInProgress();
        vsCPU=true;
        pvpRemoteActive = false;
        gamePaired = false;
        init(); // This will set cpuBtn active
    });

    [easyBtn,mediumBtn,hardBtn].forEach(btn=>btn.addEventListener('click',e=>{
        difficulty=e.target.id.replace('Btn','');
        updateAllUIToggleButtons();
        playSound('move');
        // Only re-init if a game is not active or if it's a CPU game settings change.
        // Avoid re-init if remote game is paired and active, or if a local game is active.
        // Player can change CPU difficulty mid-thought, but usually applied on next game.
        if(!gameActive || vsCPU) init();
    }));

    [player1StartsBtn,randomStartsBtn,loserStartsBtn].forEach(btn=>btn.addEventListener('click',e=>{
        whoGoesFirstSetting=e.target.id.replace('StartsBtn','');
        localStorage.setItem('whoGoesFirstSetting',whoGoesFirstSetting);
        updateAllUIToggleButtons();
        playSound('move');
        // This setting primarily affects local PvP and vs CPU.
        // For PvP Remote, host (P1) always starts currently.
        // Re-init only if no game is active or board is clear to apply new start setting.
        if(!gameActive || board.every(c=>c===null)) init();
    }));

    changeSymbolsBtn.addEventListener('click',changeSymbols);
    themeToggle.addEventListener('click',toggleTheme);
    soundToggle.addEventListener('click',toggleSound);
    document.addEventListener('dblclick',e=>e.preventDefault(),{passive:false}); // Prevent double click zoom

    /* ----------  INICIALIZACI√ìN  ---------- */
    if(localStorage.getItem('darkTheme')==='true') document.body.classList.add('dark-theme');
    updateScoreboard();
    
    // Default to local PvP active if no other mode is explicitly set (e.g. from localStorage or a unfinished remote session)
    // The init() function will call updateAllUIToggleButtons() which handles the visual state.
    // The actual mode (vsCPU, pvpRemoteActive) should be false by default unless specific buttons are clicked.
    // pvpLocalBtn will become active via updateAllUIToggleButtons if others are false.
    init(); 
});

/* ----------  PWA bootstrap  ---------- */
if('serviceWorker' in navigator){
  window.addEventListener('load', ()=>{
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('SW registered!', reg))
      .catch(err=>console.error('SW registration failed:',err));
  });
}
</script>
</body>
</html>